# Key concepts of Parsing Theory

Key concepts of Parsing Theory.

<!-- [:arrow_down: Tags legend](#tags-legend) at the end of the page. -->

<!-- - []() by []() ( _:movie_camera:_ ) -->

<!-- ## Architecture -->

## Chomsky's hierarchy of grammars

##### Type 0: **Unrestricted Grammar**
- Production Rule: α → β
  - α is a string of terminals and/or non-terminals with at least one non-terminal
  - β is a string of terminals and/or non-terminals
- Can generate any language that can be recognized by a Turing machine.

##### Type 1: **Context-Sensitive Grammar** ~ **CSG**
- Production Rule: αAβ → αγβ
  - A is a non-terminal
  - α, β, γ are strings of terminals and/or non-terminals
- The length of αβ must be less than or equal to the length of αγβ.
- Can generate context-sensitive languages.

##### Type 2: **Context-Free Grammar** ~ **CFG**
- Production Rule: A → γ
  - A is a non-terminal
  - γ is a string of terminals and/or non-terminals
- Can generate context-free languages, which are recognized by pushdown automata.

##### Type 3: **Regular Grammar**
- Right Linear Grammar (RLG):
  - Production Rule: A → aB or A → a
    - A and B are non-terminals
    - a is a terminal
- Left Linear Grammar (LLG):
  - Production Rule: A → Ba or A → a
    - A and B are non-terminals
    - a is a terminal
- Can generate regular languages, which are recognized by finite automata.

## RLG ~ Right Linear Grammar

A type of regular grammar where production rules are of the form A → aB or A → a, with non-terminals appearing on the right side of the terminal. Where A and B are non-terminals and a is a terminal.

## LLG ~ Left Linear Grammar

A type of regular grammar where production rules are of the form A → Ba or A → a, with non-terminals appearing on the left side of the terminal. Where A and B are non-terminals and a is a terminal.

## Left Most Derivative ~ Leftmost Derivation

A process in formal grammar where the leftmost non-terminal in a string is replaced first during each step of the derivation sequence. This concept is particularly relevant to context-free grammars (CFGs) and is commonly used in parsing techniques like LL parsers, which read input from left to right and construct a leftmost derivation of the sentence.

## Right Most Derivative ~ Rightmost Derivation

A process in formal grammar where the rightmost non-terminal in a string is replaced first during each step of the derivation sequence. This is especially relevant to context-free grammars (CFGs) and is used in parsing techniques like LR parsers, which read input from left to right and construct a rightmost derivation in reverse.

## Ambiguity in CFG

Ambiguity in grammar occurs when a single string can be generated by a grammar in more than one distinct way, resulting in multiple parse trees or derivations. This means that the grammar allows for more than one interpretation of the structure of the string.

Ambiguity is particularly relevant to context-free grammars (CFGs) because they are often used to define the syntax of programming languages, where unambiguous interpretation is crucial. However, ambiguity can also occur in other types of grammars, but it is most commonly discussed in the context of CFGs due to their widespread use in language parsing and compiler design.

```text

Context Free Grammar: E → E + E | E × E | id

Left Most Derivation:     Right Most Derivation:    Parse Tree Derivation:

 E ⇒ E + E                 E ⇒ E + E                    E
   ⇒ id + E                  ⇒ E + E × E               / \
   ⇒ id + E x E              ⇒ E + E × id             E + E
   ⇒ id + id x E             ⇒ E + id × id            |   /\
   ⇒ id + id x id            ⇒ id + id × id          id  E * E
                                                          |   |
                                                         id   id

 E ⇒ E x E                 E ⇒ E x E                     E
   ⇒ E + E x E               ⇒ E x id                   / \
   ⇒ id + E x E              ⇒ E + E x id              E * E
   ⇒ id + id x E             ⇒ E + id x id            / \  |
   ⇒ id + id x id            ⇒ id + id x id          E + E id
                                                      |   |
                                                     id  id
```

## Left Recursion / Right Recursion

```text

Left Recursion ~ Left Associativity

A → Aα | β

  A                  A                   A
  |                 / \                 / \
  β                A   α               A   α
                   |                  / \
                   β                 A   α
                                     |
                                     β

Right Recursion ~ Right Associativity

A → αA | β

  A                  A                  A
  |                 / \                / \
  β                α   A              α   A
                       |                 / \
                       β                α   A
                                            |
                                            β

```

## Elimination of Left Recursion

If left recursion is indirect (involving multiple non-terminals), the grammar must first be transformed to remove indirect recursion by reordering or rewriting rules.

Direct left recursion occurs when a non-terminal directly calls itself on the left side of its production. By eliminating left recursion, the grammar becomes suitable for top-down parsing methods, which require non-left-recursive ( in case of parsing from left to right ) grammars to function correctly.

```text

Original Grammar Rule:
  A → Aα | β

Transformed Grammar to Remove Left Recursion:
  A → βA'
  A' → αA' | ε
```

## Left Refactoring

Left factoring is a technique used to transform a grammar to convert it into deteministic one to make it suitable for predictive parsing, such as LL parsers.

It is applied when a grammar has production rules with common prefixes, which can cause ambiguity in deciding which production to use during parsing. Left factoring helps eliminate this ambiguity by restructuring the grammar. But bear in mind that deterministic grammar does not guarantee unambiguous.

Left Factoring Process

```text
  Identify Common Prefixes:
    Look for non-terminals with multiple productions that share a common prefix. For example, consider the productions:
      A → αβ₁
      A → αβ₂

  Factor Out the Common Prefix:
    Introduce a new non-terminal to represent the common prefix and rewrite the productions. For the example above:
      Introduce a new non-terminal A'.
      Rewrite the productions as:
        A → αA'
        A' → β₁ | β₂

  Example

    Original Grammar:
      A → aAB | aBc | aAc

    Intermidiary Step:
      A → aA'
      A' → AB | Ac | Bc

    Refactored Grammar:
      A → aA'
      A' → AA'' | Bc
      A'' → B | c

  Ambigious Example

    Original Grammar:
      S → iEtS | iEtSeS | a
      E → b

    Refactored Grammar:
      S → iEtSS' | a
      S' → ε | eS
      E → b

  Example

    Original Grammar:
      S → aSSbS | aSaSb | abb | b

    Intermidiary Step:
      S → aS' | b
      S' → SSbS | SaSb | bb

    Refactored Grammar:
      S → aS' | b
      S' → SS'' | bb
      S'' → SbS | aSb

  Example

    Original Grammar:
      S → bSSaaS | bSSaSb | bSb | a

    Intermidiary Step:
      S → bS' | a
      S' → SaaS | SaSb | b

    Refactored Grammar:
      S → bSS' | a
      S' → SaS'' | b
      S'' → aS | Sb

  Example

    Original Grammar:
      S → a | ab | abc | abcd

    Refactored Grammar:
      S → aS'
      S' → bS'' | ε
      S'' → cS''' | ε
      S''' → d | ε

```

## First, Follow Functions

The First function helps determine which terminal symbols can appear at the beginning of strings derived from a given grammar symbol.

The Follow function determines which terminal symbols can appear immediately after a non-terminal in some "sentential" form.

> Example

| Production | FIRST     | FOLLOW   |
|------------|-----------|----------|
| S → ABCDE  | {a, b, c} | {$}      |
| A → a      | {a, ε}    | {b, c}   |
| B → b      | {b, ε}    | {c}      |
| C → c      | {c}       | {d, e, $}|
| D → d      | {d, ε}    | {e, $}   |
| E → e      | {e, ε}    | {$}      |

> Example

| Production | FIRST    | FOLLOW   |
|------------|----------|----------|
| S → aBDh   | {a}      | {$}      |
| B → c      | {c}      | {g, f, h}|
| C → bC ε   | {b, ε}   | {g, f, h}|
| D → EF     | {g, f, ε}| {g, f, h}|
| E → g ε    | {g, ε}   | {f, h}   |
| F → f ε    | {f, ε}   | {h}      |
